(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    /* 
        Directed acyclic graph (for storing triangle hierachy)
    */ 
    
    var _ = require('underscore'); 
    
    var DAG = function() {
        this.adj = {}; // maps to t_ids to adjacency lists  
    }; 
    
    DAG.prototype.addDirectedEdge = function(n1, n2) {
        if (this.adj[n1] == undefined) this.adj[n1] = [n2];
        else this.adj[n1].push(n2); 
    };
    
    // or "neighbors"
    DAG.prototype.children = function(n) {
        return this.adj[n]; 
    }; 
    
    DAG.prototype.root = function() { 
        return _.last(_.keys(this.adj)); 
    }; 
    
    module.exports = DAG; 
    },{"underscore":6}],2:[function(require,module,exports){
    /* 
        SVG drawing and GUI control methods
    */
    
    var _ = require('underscore'); 
    var util = require('./util'); 
    var kirkpatrick = require('./point-location'); 
    
    var svg = d3.select("#canvas")
    .append("svg")
    .attr("width", "100%")
    .attr("height", "100%");
    
    var drawPoint = function(p, color) { 
        svg.append("circle")
        .attr("cx", p.x + "px")
        .attr("cy", p.y + "px")
        .attr("r", "4px")
        .attr("fill", color); 
    }; 
    
    var drawLine = function(a, b, color) { 
        console.log("drawLine");
        svg.append("line")  
            .attr("stroke-width", 2)
            .attr("stroke", color)
            .attr("x1", a.x)
            .attr("y1", a.y)
            .attr("x2", b.x)
            .attr("y2", b.y);
    }; 

    var drawSquare = function(pts, stroke, fill, label){
        console.log("drawSquare");
        var s = "M" + pts[0].x + "," + pts[0].y 
        + ", L " + pts[1].x + "," + pts[1].y 
        + ", L " + pts[2].x + "," + pts[2].y
        + ", L " + pts[3].x + "," + pts[3].y
        + ", Z";
        _.each(pts, (p) => drawPoint(p, stroke));
        svg.append("path")    
        .attr("stroke-width", "2px")     
        .attr("stroke", stroke)  
        .attr("fill", fill)     
        .attr("d", s);  
    }
    
    var drawTriangle = function(pts, stroke, fill, label) { 
        console.log("drawTriangle");
        var s = "M" + pts[0].x + "," + pts[0].y 
        + ", L " + pts[1].x + "," + pts[1].y 
        + ", L " + pts[2].x + "," + pts[2].y 
        + ", Z"; 
    
        _.each(pts, (p) => drawPoint(p, stroke)); 
    
        svg.append("path")    
        .attr("stroke-width", "2px")     
        .attr("stroke", stroke)  
        .attr("fill", fill)     
        .attr("d", s);  
    
        var center = [(pts[0].x + pts[1].x + pts[2].x)/3, (pts[0].y + pts[1].y + pts[2].y)/3]; 
    
        if (label != undefined) {
            svg.append("text")
            .attr("x", center[0])
            .attr("y", center[1])
            .text(label + "");
        } 
    }; 
    
    var highlightTriangle = function(pts, stroke, fill, label) { 
        var s = "M" + pts[0].x + "," + pts[0].y 
        + ", L " + pts[1].x + "," + pts[1].y 
        + ", L " + pts[2].x + "," + pts[2].y 
        + ", Z"; 
    
        svg.append("path")    
        .attr("stroke-width", "2px")     
        .attr("stroke", stroke)  
        .attr("fill", fill)     
        .attr("d", s);  
    
        var center = [(pts[0].x + pts[1].x + pts[2].x)/3, (pts[0].y + pts[1].y + pts[2].y)/3]; 
    
        if (label != undefined) {
            svg.append("text")
            .attr("x", center[0])
            .attr("y", center[1])
            .text(label + "");
        } 
    }; 
    
    var drawTriangulation = function(tris, graph) { 
        _.each(tris, function(t) { 
            var tri = graph.all_triangles[t]; 
            var pts = [tri.v1, tri.v2, tri.v3]; 
            pts = _.map(pts, (p) => graph.vertices[p].point); 
    
            drawTriangle(pts, "gray", "none", t); 
        }); 
    }; 
    
    var drawGraph = function(graph, color) { 
        // draw all points 
        _.each(graph.vertices, function(v) {
            if (!v.removed) 
                drawPoint(v.point, color);
        }); 
    
        // draw all edges 
        _.each(graph.adj, function(nbors, i) { 
            var p1 = graph.vertices[i].point; 
            var p2; 
            _.each(nbors, function(n) { 
                p2 = graph.vertices[n].point;
                drawLine(p1, p2, color); 
            });
        }); 
    }; 
    
    var buttons = { 
        closePolygon: d3.select("#closePolygon"),
        triangulate: d3.select("#triangulate"),
        findIndependentSet: d3.select("#findIndependentSet"),
        remove: d3.select("#remove"),
        reset: d3.select("#reset"),
        step: d3.select("#step"),
        locateAnother: d3.select("#locateAnother")
    }; 
    
    var clear = function() { 
        console.log("clear");
        // drawTriangle(kirkpatrick.outer_triangle, "black", "white");
        drawSquare(kirkpatrick.outer_boundary, "black", "white"); 
    };

    var midList = [];
    
    var reset = function() { 
        buttons.closePolygon.attr("disabled", null); 
        buttons.triangulate.attr("disabled", "disabled"); 
        buttons.findIndependentSet.attr("disabled", "disabled"); 
        buttons.remove.attr("disabled", "disabled");
        buttons.step.attr("disabled", "disabled"); 
        buttons.locateAnother.attr("disabled", "disabled"); 
    
        points = []; 
        edges = [];  
        step_count = 0; 
        query = undefined; 
    
        clear(); 

        midList = [];
    
        d3.select("#console").text("Waiting for initial input..."); 
    
        var handleClick = function() {
            var pt = d3.mouse(this); 
            var p = { x: pt[0], y: pt[1] }; 
            var last; 
            if (!_.isEmpty(points)) { 
                last = { x: _.last(points).x, y: _.last(points).y }; 
            }
    
            if (util.squareContainsPoint(p, kirkpatrick.outer_boundary)) {
                // if (!_.isEmpty(points)) { 
                //     var selfCrosses = _.reduce(edges, function(m, e) {
                //         return util.sidesIntersect(p, last, e[0], e[1]) || m; 
                //     }, false); 
                // } else { 
                //     var selfCrosses = false; 
                // }
    
                // if (!selfCrosses) { 
                //     drawPoint(p, "black");
                    
                //     if (!_.isEmpty(points)) { 
                //         drawLine(p, last, "black"); 
                //         edges.push([p, last]); 
                //     }    
    
                //     points.push(p);
                //     d3.select("#console").text("Total number of points = " + (points.length + 3)); 
                // } else { 
                //     d3.select("#console").text("No self-crosses allowed!"); 
                // }
                points.push(p);
                drawPoint(p, "black");
            }
            else {
                d3.select("#console").text("Outside of Canvas!"); 
            }
        };
    
        svg.on("click", handleClick);
    };
    
    reset(); 
    
    var points = []; 
    var edges = []; 
    var midList = [];
    
    var graph; 
    var dag; 
    var set; 
    var query; 
    var step_count; 
    var highlight; 
    var triangulation; 

    var leftPoint_upper = 0;
    var rightPoint_upper = 0;
    var leftPoint_lower = 0;
    var rightPoint_lower = 0;
    var mode = 0 ;

    var Node = function(){
        this.left = null;
        this.right =  null;
        this.previous = null;
        this.pointList = [];
        this.connectedVertex = [];
        this.rightConnectedVertex = [];
        this.leftConnectedVertex = [];
        this.finish = false;
        this.base = false;
    }

    var root = new Node();
    var cur = root;
    
    buttons.closePolygon.on("click", function() { 
        // if (points.length < 3) { 
        //     d3.select("#console").text("Select at least three points!");
        // } else { 
        //     var first = _.first(points); 
        //     var last = _.last(points); 
    
        //     var selfCrosses = _.reduce(edges, function(m, e) { 
        //         return util.sidesIntersect(first, last, e[0], e[1]) || m;
        //     }, false);
    
        //     if (selfCrosses) { 
        //         d3.select("#console").text("No self-crosses allowed!");
        //     } else { 
        //         drawLine(first, last, "black");
        //         d3.select("#console").text("Waiting to be triangulated...");
        // buttons.closePolygon.attr("disabled", "disabled"); 
                buttons.triangulate.attr("disabled", null); 
                buttons.closePolygon.attr("disabled","disabled" ); 
        //     }
        // }
        if (points.length < 2){
            d3.select("#console").text("Select at least two points!");
        } else {
            d3.select("#console").text("Bisection complete! Please click \"step\"");
            points.sort(function(a,b){
                return a.x - b.x;
            });
            // var mid = points.length/2;
            // mid = parseInt(mid, 10);
            // var lineX = (points[mid-1].x + points[mid].x)/2;
            // drawLine({x:lineX, y: 0},{x:lineX, y: 655}, "blue");
            // var l = points.length;
            // var level = 0;
            console.log(points);
            root = binaryCut(points);
            console.log(root);
            console.log(midList);
            var i = 0;
            for (i = 0; i < midList.length; i++){
                drawLine({x:midList[i], y: 5},{x:midList[i], y: 650}, "blue");
            }
            
            traverseConnect(root);
            // while (typeof node[0] != "number"){
            //     node = node[0];
            // }
            // console.log(node);
            cur = root;
            while (cur.left.left != null){
                cur = cur.left;
            }
        }
        
        
    }); 
    
    buttons.triangulate.on("click", function() { 
        // var res = kirkpatrick.run(points);
        // graph = res.graph; 
        // dag = res.dag; 
        // drawGraph(graph, "black"); 
    

        // buttons.triangulate.attr("disabled", "disabled"); 
        // buttons.findIndependentSet.attr("disabled", null); 
        clear();
        var i = 0;
        for (i = 0; i < root.pointList.length; i++){
            drawPoint(root.pointList[i], "black");
        }
        // while (cur.left.left != null){
        //     cur = cur.left;
        // }
        if (cur.finish){
            if (cur.parent != null){
                if (cur != cur.parent.right && cur.parent.right.left != null){
                    cur = cur.parent.right;
                    while (cur.left.left != null){
                        cur = cur.left;
                    }
                }else {
                    cur = cur.parent;
                }
            }
        }

        
        if (cur.left.left == null){
            cur.base = true;
            cur.left.leftConnectedVertex = clockwiseLeft(cur.left.connectedVertex);
            
        }
        if (cur.right.left == null){
            cur.right.rightConnectedVertex = clockwiseRight(cur.right.connectedVertex);
        }

        // if (cur.base){
            if ( mode == 0){
                d3.select("#console").text("Computing upper tangent...");   
                i = 0;
                for (i = 0; i < cur.pointList.length; i++){
                    drawPoint(cur.pointList[i], "gray");
                }
                i = 0;
                // var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
                // drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
                if (cur.left.pointList.length == 3){
                    drawTriangle(cur.left.pointList, "gray", "none");
                } else if (cur.left.pointList.length == 2){
                    drawLine(cur.left.pointList[0], cur.left.pointList[1],"gray");
                } else {
                    for (i =  0 ; i < cur.left.leftConnectedVertex.length-1; i ++){
                        drawLine(cur.left.leftConnectedVertex[i], cur.left.leftConnectedVertex[i+1], "gray");
                    }
                    drawLine(cur.left.leftConnectedVertex[0], cur.left.leftConnectedVertex[cur.left.leftConnectedVertex.length-1], "gray");
                }
    
                if (cur.right.pointList.length == 3){
                    drawTriangle(cur.right.pointList, "gray", "none");
                } else if (cur.right.pointList.length == 2){
                    drawLine(cur.right.pointList[0], cur.right.pointList[1],"gray");
                } else {
                    for (i =  0 ; i < cur.right.rightConnectedVertex.length-1; i ++){
                        drawLine(cur.right.rightConnectedVertex[i], cur.right.rightConnectedVertex[i+1], "gray");
                    }
                    drawLine(cur.right.rightConnectedVertex[0], cur.right.rightConnectedVertex[cur.right.rightConnectedVertex.length-1], "gray");
                }
             
                // cur.left.leftConnectedVertex=clockwiseLeft(cur.left.connectedVertex);
                // cur.right.rightConnectedVertex=clockwiseRight(cur.right.connectedVertex);
    
                drawPoint(cur.left.leftConnectedVertex[leftPoint_upper], "red");
                drawPoint(cur.right.rightConnectedVertex[rightPoint_upper], "red");
                var left_next = (leftPoint_upper+1)%cur.left.leftConnectedVertex.length;
                
                var right_next = (rightPoint_upper+1)%cur.right.rightConnectedVertex.length;
                var ori1 = orient(cur.right.rightConnectedVertex[rightPoint_upper], cur.left.leftConnectedVertex[leftPoint_upper], cur.left.leftConnectedVertex[left_next]);
                if(ori1>=0){
                    drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "yellow");
                    leftPoint_upper = leftPoint_upper +1;
                }else{
                    var ori2 = orient(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], cur.right.rightConnectedVertex[right_next]);
                    if(ori2<=0){
                        drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "yellow");
                        rightPoint_upper = rightPoint_upper + 1;
                    }
                    else{
                        drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "green");
                        mode = 1;
                        // switch to find the lower tangent, reset value 
                        // fill this blank to add the edge to the to connected component
                        // do not forget to find set left_upper and right_upper to zero 
                        d3.select("#console").text("This is upper tangent!");   
                    }
    
                }
                var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
                drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
                
            }
            else if(mode == 1){
                d3.select("#console").text("Computing lower tangent");
                console.log("In mode 1")
                i = 0;
                for (i = 0; i < cur.pointList.length; i++){
                    drawPoint(cur.pointList[i], "gray");
                }
                i = 0;
                // var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
                // drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
                if (cur.left.pointList.length == 3){
                    drawTriangle(cur.left.pointList, "gray", "none");
                } else if (cur.left.pointList.length == 2){
                    drawLine(cur.left.pointList[0], cur.left.pointList[1],"gray");
                } else {
                    for (i =  0 ; i < cur.left.leftConnectedVertex.length-1; i ++){
                        drawLine(cur.left.leftConnectedVertex[i], cur.left.leftConnectedVertex[i+1], "gray");
                    }
                    drawLine(cur.left.leftConnectedVertex[0], cur.left.leftConnectedVertex[cur.left.leftConnectedVertex.length-1], "gray");
                }
    
                if (cur.right.pointList.length == 3){
                    drawTriangle(cur.right.pointList, "gray", "none");
                } else if (cur.right.pointList.length == 2){
                    drawLine(cur.right.pointList[0], cur.right.pointList[1],"gray");
                } else {
                    for (i =  0 ; i < cur.right.rightConnectedVertex.length-1; i ++){
                        drawLine(cur.right.rightConnectedVertex[i], cur.right.rightConnectedVertex[i+1], "gray");
                    }
                    drawLine(cur.right.rightConnectedVertex[0], cur.right.rightConnectedVertex[cur.right.rightConnectedVertex.length-1], "gray");
                }
                
                // cur.left.leftConnectedVertex=clockwiseLeft(cur.left.connectedVertex);
                // cur.right.rightConnectedVertex=clockwiseRight(cur.right.connectedVertex);
    
                drawPoint(cur.left.leftConnectedVertex[leftPoint_lower], "red");
                drawPoint(cur.right.rightConnectedVertex[rightPoint_lower], "red");
                if(leftPoint_lower==0){
                    var left_next = leftPoint_lower - 1 + cur.left.leftConnectedVertex.length;
                }
                else{
                    var left_next = leftPoint_lower - 1;
                }
                console.log(left_next);
                if(rightPoint_lower==0){
                    var right_next = rightPoint_lower-1 + cur.right.rightConnectedVertex.length;
                }
                else{
                    var right_next = rightPoint_lower-1;
                }
                console.log(right_next);           
                var ori1 = orient(cur.right.rightConnectedVertex[rightPoint_lower], cur.left.leftConnectedVertex[leftPoint_lower], cur.left.leftConnectedVertex[left_next]);
                if(ori1<=0){
                    drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "yellow");
                    if(leftPoint_lower==0){
                        leftPoint_lower = leftPoint_lower - 1 + cur.left.leftConnectedVertex.length;
                    }
                    else{
                        leftPoint_lower = leftPoint_lower - 1;
                    }
                }else{
                    var ori2 = orient(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], cur.right.rightConnectedVertex[right_next]);
                    if(ori2>=0){
                        drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "yellow");
                        if(rightPoint_lower==0){
                            rightPoint_lower = rightPoint_lower- 1 + cur.right.rightConnectedVertex.length;
                        }
                        else{
                            rightPoint_lower = rightPoint_lower-1;
                        }
                    }
                    else{
                        drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "green");
                        mode = 2;
                        d3.select("#console").text("This is lower tangent!");   
                    }
    
                }
                var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
                drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
    
                
            }
            else{
                d3.select("#console").text("Outputing Convex Hull!");
                i = 0;
                var left_most = 999;
                var leftIndex = 0;
                for (i = 0; i < cur.left.leftConnectedVertex.length; i++){
                    if (cur.left.leftConnectedVertex[i].x < left_most){
                        left_most = cur.left.leftConnectedVertex[i].x;
                        leftIndex = i;
                    }
                }
                // console.log(leftIndex);
                var right_most = 0;
                var rightIndex = 0;
                for (i = 0; i < cur.right.rightConnectedVertex.length; i++){
                    if (cur.right.rightConnectedVertex[i].x > right_most){
                        right_most = cur.right.rightConnectedVertex[i].x;
                        rightIndex = i;
                    }
                }
    
                cur.connectedVertex = [];
    
                // if (leftPoint_upper == 0){
                    
                // } else {
                //     for (i = leftIndex; i >= leftPoint_upper; i--){
                //         cur.connectedVertex.push(cur.left.leftConnectedVertex[i]);
                //     }
                // }
                for (i = leftIndex; i >= leftPoint_upper; i--){
                    cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[i]);
                }
                // console.log(rightPoint_upper);
                // console.log(rightPoint_lower);
                if (rightPoint_lower == 0){
                    for (i = rightPoint_upper; i <= cur.right.rightConnectedVertex.length-1; i++){
                        cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[i]);
                    }
                    cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[0]);
                } else {
                    for (i = rightPoint_upper; i <= rightPoint_lower; i++){
                        cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[i]);
                    }
                }
                
                if (leftPoint_lower == 0){
                    cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[0]);
                    for (i =  cur.left.leftConnectedVertex.length-1; i > leftIndex; i--){
                        cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[i]);
                    }
                } else {
                    for (i = leftPoint_lower; i > leftIndex; i--){
                        cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[i]);
                    }
                }
    
                //RightConnect
    
                for (i = rightIndex; i >= rightPoint_upper; i--){
                    cur.leftConnectedVertex.push(cur.right.rightConnectedVertex[i]);
                }
    
                if (leftPoint_lower == 0){
                    for (i = leftPoint_upper; i <= cur.left.leftConnectedVertex.length-1; i++){
                        cur.leftConnectedVertex.push(cur.left.leftConnectedVertex[i]);
                    }
                    cur.leftConnectedVertex.push(cur.left.leftConnectedVertex[0]);
                } else {
                    for (i = leftPoint_upper; i <= leftPoint_lower; i++){
                        cur.leftConnectedVertex.push(cur.left.leftConnectedVertex[i]);
                    }
                }
                
                if (rightPoint_lower == 0){
                    cur.leftConnectedVertex.push(cur.right.rightConnectedVertex[0]);
                    for (i =  cur.right.rightConnectedVertex.length-1; i > rightIndex; i--){
                        cur.leftConnectedVertex.push(cur.right.rightConnectedVertex[i]);
                    }
                } else {
                    for (i = rightPoint_lower; i > rightIndex; i--){
                        cur.leftConnectedVertex.push(cur.right.rightConnectedVertex[i]);
                    }
                }
                
    
    
    
                // console.log(cur.leftConnectedVertex);
                // for (var i = 0; i < cur.leftConnectedVertex.length-1;i++){
                //     drawLine(cur.leftConnectedVertex[i], cur.leftConnectedVertex[i+1], "black");
                // }
                // drawLine(cur.leftConnectedVertex[0], cur.leftConnectedVertex[cur.leftConnectedVertex.length-1], "black");
                console.log(cur.rightConnectedVertex);
                for (var i = 0; i < cur.rightConnectedVertex.length-1;i++){
                    drawLine(cur.rightConnectedVertex[i], cur.rightConnectedVertex[i+1], "black");
                }
                drawLine(cur.rightConnectedVertex[0], cur.rightConnectedVertex[cur.rightConnectedVertex.length-1], "black");

                cur.finish = true;
                mode =0;
                rightPoint_lower = 0;
                rightPoint_upper = 0;
                leftPoint_lower = 0;
                leftPoint_upper = 0;
                if((cur.parent==null)&&cur.finish){
                    buttons.triangulate.attr("disabled","disabled"); 
                }
            }
            //
            //
            //
        // } else {
            // if ( mode == 0){   
            //     var i = 0;
            //     for (i = 0; i < cur.pointList.length; i++){
            //         drawPoint(cur.pointList[i], "gray");
            //     }
            //     i = 0;
            //     var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
            //     drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
            //     if (cur.left.pointList.length == 3){
            //         drawTriangle(cur.left.pointList, "gray", "none");
            //     } else if (cur.left.pointList.length == 2){
            //         drawLine(cur.left.pointList[0], cur.left.pointList[1],"gray");
            //     } else {
            //         for (i =  0 ; i < cur.left.leftConnectedVertex.length-1; i ++){
            //             drawLine(cur.left.leftConnectedVertex[i], cur.left.leftConnectedVertex[i+1]);
            //         }
            //         drawLine(cur.left.leftConnectedVertex[0], cur.left.leftConnectedVertex[cur.left.leftConnectedVertex.length-1], "gray");
            //     }
    
            //     if (cur.right.pointList.length == 3){
            //         drawTriangle(cur.right.pointList, "gray", "none");
            //     } else if (cur.right.pointList.length == 2){
            //         drawLine(cur.right.pointList[0], cur.right.pointList[1],"gray");
            //     } else {
            //         for (i =  0 ; i < cur.right.rightConnectedVertex.length-1; i ++){
            //             drawLine(cur.right.rightConnectedVertex[i], cur.right.rightConnectedVertex[i+1]);
            //         }
            //         drawLine(cur.right.rightConnectedVertex[0], cur.right.rightConnectedVertex[cur.right.rightConnectedVertex.length-1], "gray");
            //     }

                
            //     for (i =  0 ; i < cur.left.leftConnectedVertex.length; i ++){

            //     }
             
            //     // cur.left.leftConnectedVertex=clockwiseLeft(cur.left.connectedVertex);
            //     // cur.right.rightConnectedVertex=clockwiseRight(cur.right.connectedVertex);
    
            //     drawPoint(cur.left.leftConnectedVertex[leftPoint_upper], "red");
            //     drawPoint(cur.right.rightConnectedVertex[rightPoint_upper], "red");
            //     var left_next = (leftPoint_upper+1)%cur.left.leftConnectedVertex.length;
                
            //     var right_next = (rightPoint_upper+1)%cur.right.rightConnectedVertex.length;
            //     var ori1 = orient(cur.right.rightConnectedVertex[rightPoint_upper], cur.left.leftConnectedVertex[leftPoint_upper], cur.left.leftConnectedVertex[left_next]);
            //     if(ori1>=0){
            //         drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "yellow");
            //         leftPoint_upper = leftPoint_upper +1;
            //     }else{
            //         var ori2 = orient(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], cur.right.rightConnectedVertex[right_next]);
            //         if(ori2<=0){
            //             drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "yellow");
            //             rightPoint_upper = rightPoint_upper + 1;
            //         }
            //         else{
            //             drawLine(cur.left.leftConnectedVertex[leftPoint_upper], cur.right.rightConnectedVertex[rightPoint_upper], "green");
            //             mode = 1;
            //             // switch to find the lower tangent, reset value 
            //             // fill this blank to add the edge to the to connected component
            //             // do not forget to find set left_upper and right_upper to zero 
    
            //         }
    
            //     }
            //     var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
            //     drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
                
            // }
            // else if(mode == 1){
            //     console.log("In mode 1")
            //     i = 0;
            //     for (i = 0; i < cur.pointList.length; i++){
            //         drawPoint(cur.pointList[i], "gray");
            //     }
            //     i = 0;
            //     // var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
            //     // drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
            //     if (cur.left.pointList.length == 3){
            //         drawTriangle(cur.left.pointList, "gray", "none");
            //     } else if (cur.left.pointList.length == 2){
            //         drawLine(cur.left.pointList[0], cur.left.pointList[1],"gray");
            //     }
    
            //     if (cur.right.pointList.length == 3){
            //         drawTriangle(cur.right.pointList, "gray", "none");
            //     } else if (cur.right.pointList.length == 2){
            //         drawLine(cur.right.pointList[0], cur.right.pointList[1],"gray");
            //     }
                
            //     // cur.left.leftConnectedVertex=clockwiseLeft(cur.left.connectedVertex);
            //     // cur.right.rightConnectedVertex=clockwiseRight(cur.right.connectedVertex);
    
            //     drawPoint(cur.left.leftConnectedVertex[leftPoint_lower], "red");
            //     drawPoint(cur.right.rightConnectedVertex[rightPoint_lower], "red");
            //     if(leftPoint_lower==0){
            //         var left_next = leftPoint_lower - 1 + cur.left.leftConnectedVertex.length;
            //     }
            //     else{
            //         var left_next = leftPoint_lower - 1;
            //     }
            //     console.log(left_next);
            //     if(rightPoint_lower==0){
            //         var right_next = rightPoint_lower-1 + cur.right.rightConnectedVertex.length;
            //     }
            //     else{
            //         var right_next = rightPoint_lower-1;
            //     }
            //     console.log(right_next);           
            //     var ori1 = orient(cur.right.rightConnectedVertex[rightPoint_lower], cur.left.leftConnectedVertex[leftPoint_lower], cur.left.leftConnectedVertex[left_next]);
            //     if(ori1<=0){
            //         drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "yellow");
            //         if(leftPoint_lower==0){
            //             leftPoint_lower = leftPoint_lower - 1 + cur.left.leftConnectedVertex.length;
            //         }
            //         else{
            //             leftPoint_lower = leftPoint_lower - 1;
            //         }
            //     }else{
            //         var ori2 = orient(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], cur.right.rightConnectedVertex[right_next]);
            //         if(ori2>=0){
            //             drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "yellow");
            //             if(rightPoint_lower==0){
            //                 rightPoint_lower = rightPoint_lower- 1 + cur.right.rightConnectedVertex.length;
            //             }
            //             else{
            //                 rightPoint_lower = rightPoint_lower-1;
            //             }
            //         }
            //         else{
            //             drawLine(cur.left.leftConnectedVertex[leftPoint_lower], cur.right.rightConnectedVertex[rightPoint_lower], "green");
            //             mode = 2;
            //             // switch to find the lower tangent, reset value 
    
            //             // ```
            //             // fill this blank to add the edge to the to connected component
            //             // do not forget to find set left_upper and right_upper to zero 
            //             // ```
            //         }
    
            //     }
            //     var linex = (cur.left.leftConnectedVertex[0].x + cur.right.rightConnectedVertex[0].x)/2;
            //     drawLine({x:linex, y: 5},{x:linex, y: 650}, "blue");
    
                
            // }
            // else{
            //     i = 0;
            //     var left_most = 999;
            //     var leftIndex = 0;
            //     for (i = 0; i < cur.left.leftConnectedVertex.length; i++){
            //         if (cur.left.leftConnectedVertex[i].x < left_most){
            //             left_most = cur.left.leftConnectedVertex[i].x;
            //             leftIndex = i;
            //         }
            //     }
            //     // console.log(leftIndex);
            //     var right_most = 0;
            //     var rightIndex = 0;
            //     for (i = 0; i < cur.right.rightConnectedVertex.length; i++){
            //         if (cur.right.rightConnectedVertex[i].x > right_most){
            //             right_most = cur.right.rightConnectedVertex[i].x;
            //             rightIndex = i;
            //         }
            //     }
    
            //     cur.connectedVertex = [];
    
            //     // if (leftPoint_upper == 0){
                    
            //     // } else {
            //     //     for (i = leftIndex; i >= leftPoint_upper; i--){
            //     //         cur.connectedVertex.push(cur.left.leftConnectedVertex[i]);
            //     //     }
            //     // }
            //     for (i = leftIndex; i >= leftPoint_upper; i--){
            //         cur.connectedVertex.push(cur.left.leftConnectedVertex[i]);
            //     }
            //     // console.log(rightPoint_upper);
            //     // console.log(rightPoint_lower);
            //     if (rightPoint_lower == 0){
            //         for (i = rightPoint_upper; i <= cur.right.rightConnectedVertex.length-1; i++){
            //             cur.connectedVertex.push(cur.right.rightConnectedVertex[i]);
            //         }
            //         cur.connectedVertex.push(cur.right.rightConnectedVertex[0]);
            //     } else {
            //         for (i = rightPoint_upper; i <= rightPoint_lower; i++){
            //             cur.connectedVertex.push(cur.right.rightConnectedVertex[i]);
            //         }
            //     }
                
            //     if (leftPoint_lower == 0){
            //         cur.connectedVertex.push(cur.left.leftConnectedVertex[0]);
            //         for (i =  cur.left.leftConnectedVertex.length-1; i > leftIndex; i--){
            //             cur.connectedVertex.push(cur.left.leftConnectedVertex[i]);
            //         }
            //     } else {
            //         for (i = leftPoint_lower; i > leftIndex; i--){
            //             cur.connectedVertex.push(cur.left.leftConnectedVertex[i]);
            //         }
            //     }
    
            //     //RightConnect
    
            //     for (i = rightIndex; i >= rightPoint_upper; i--){
            //         cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[i]);
            //     }
    
            //     if (leftPoint_lower == 0){
            //         for (i = leftPoint_upper; i <= cur.left.leftConnectedVertex.length-1; i++){
            //             cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[i]);
            //         }
            //         cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[0]);
            //     } else {
            //         for (i = leftPoint_upper; i <= leftPoint_lower; i++){
            //             cur.rightConnectedVertex.push(cur.left.leftConnectedVertex[i]);
            //         }
            //     }
                
            //     if (rightPoint_lower == 0){
            //         cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[0]);
            //         for (i =  cur.right.rightConnectedVertex.length-1; i > rightIndex; i--){
            //             cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[i]);
            //         }
            //     } else {
            //         for (i = rightPoint_lower; i > rightIndex; i--){
            //             cur.rightConnectedVertex.push(cur.right.rightConnectedVertex[i]);
            //         }
            //     }
                
    
    
    
            //     console.log(cur.connectedVertex);
            //     for (var i = 0; i < cur.connectedVertex.length-1;i++){
            //         drawLine(cur.connectedVertex[i], cur.connectedVertex[i+1], "black");
            //     }
            //     drawLine(cur.connectedVertex[0], cur.connectedVertex[cur.connectedVertex.length-1], "black");
            //     cur.finish = true;
            //     mode =0;
            // }
        // }
        
    }); 
    
    buttons.findIndependentSet.on("click", function() { 
        set = kirkpatrick.findIndependentSet(graph); 
        _.each(set, (v) => drawPoint(graph.vertices[v].point, "red")); 
    
        d3.select("#console").text("Waiting to remove independent set...");
        buttons.findIndependentSet.attr("disabled", "disabled"); 
        buttons.remove.attr("disabled", null); 
    }); 
    
    buttons.remove.on("click", function() { 
        // var tris = kirkpatrick.removeVertices(graph, set, dag); 
        clear(); 
        // drawGraph(graph, "black"); 
    
        // if (graph.numVertices == 3) {
        //     locatePoint(); 
        // } else {
        //     d3.select("#console").text("Waiting to identify independent set...");
        //     buttons.findIndependentSet.attr("disabled", null); 
        // }
    
        // buttons.remove.attr("disabled", "disabled");
        var i = 0;
         
    }); 

    var clockwiseRight = function(l){
        if (l.length > 2){
            if (orient(l[0], l[1], l[2]) < 0 ){
                var tmp = l[1];
                l[1] = l[2];
                l[2] = tmp;
            }
        }
        return l;
    };

    var clockwiseLeft = function(l){
        if (l.length > 2){
            if (orient(l[0],l[1], l[2]) > 0){
                var tmp = l[1];
                l[1] = l[2];
                l[2] = tmp;
            }
        }
        return l;
    }

    var orient =  function(point1, point2, point3){
        var vector1 = {x:point2.x-point1.x, y:point2.y-point1.y};
        var vector2 = {x:point3.x-point2.x, y:point3.y-point2.y};
        var cross_product = vector1.x * vector2.y - vector1.y * vector2.x;
        // console.log("point1");
        // console.log(point1.x);
        // console.log("point2");
        // console.log(point2.x);
        // console.log("point3");
        // console.log(point3.x);      
        return cross_product;
        }
    
    var locatePoint = function() {
        clear();
        step_count = 0;
        query = undefined;  
        d3.select("#console").text("Waiting for query point selection...");
        drawTriangulation(_.first(graph.triangulations), graph); 
    
        var handleClick = function() { 
            var pt = d3.mouse(this); 
            var p = { x: pt[0], y: pt[1] };
            if (util.squareContainsPoint(p, kirkpatrick.outer_boundary)) {
                if (query == undefined) { 
                    query = p;
                    drawPoint(query, "green"); 
                    buttons.step.attr("disabled", null); 
                    buttons.locateAnother.attr("disabled", "disabled"); 
    
                    highlight = dag.root(); 
                    step_count = 1;  
                    triangulation = dag.children(highlight); 
                } else { 
                    d3.select("#console").text("Query point already selected!");
                }
            } else {
                d3.select("#console").text("Outside of triangle!"); 
            }
        };
        svg.on("click", handleClick); 
    }; 

    var binaryCut = function (points){
        // console.log("hehe");
        if (points.length <= 3){
            var baseNode = new Node();
            baseNode.pointList = points;
            baseNode.pointList.sort(function(a,b){
                return a.x - b.x;
            });
            return baseNode;
        }
        var mid = (points.length+1) /2;
        mid = parseInt(mid);
        midList.push((points[mid-1].x + points[mid].x)/2);
        // return {binaryCut(points.slice(0, mid), binaryCut[mid, points.length-1]}; 
        // var res = [];
        var n = new Node();
        n.left = binaryCut(points.slice(0, mid));
        n.left.parent = n;
        n.right = binaryCut(points.slice(mid, points.length));
        n.right.parent =n;
        n.pointList.push(...n.left.pointList, ...n.right.pointList);
        // var left = binaryCut(points.slice(0, mid));
        // var right = binaryCut(points.slice(mid, points.length));
        // res.push(left);
        // res.push(right);
        return n;
    };

    var traverseConnect = function(node){
        console.log("Connect");
        node.connectedVertex = node.pointList;
        if ( node.left == null || node.right == null){
            if (node.pointList.length == 3){
                drawTriangle(node.pointList, "gray", "none" );
            } else if (node.pointList.length == 2) {
                drawLine(node.pointList[0], node.pointList[1],"gray");
                drawPoint(node.pointList[0], "gray");
                drawPoint(node.pointList[1], "gray");
            }

            
        }
        if (node.left != null){
            traverseConnect(node.left);
            if (node.left.left ==null || node.left.right == null){
                // node.left.leftConnectedVertex.sort(function(a, b){
                //     return b.x - a.x;
                // });
                node.left.connectedVertex.reverse();
            }
        }
        if (node.right != null){
            traverseConnect(node.right);
        }
        
    };
    
    buttons.step.on("click", function() { 
        var len = _.size(graph.triangulations); 
        clear(); 
    
        if (step_count >= len) { 
            clear();
    
            d3.select("#console").text("SUCCESS: Point located!");
    
            drawTriangulation(_.first(graph.triangulations), graph); 
            var tri = graph.all_triangles[highlight]; 
            var pts = [tri.v1, tri.v2, tri.v3]; 
            pts = _.map(pts, (p) => graph.vertices[p].point); 
            drawTriangle(pts, "gray", "yellow", highlight); 
            drawPoint(query, "green");
    
            buttons.step.attr("disabled", "disabled"); 
            buttons.locateAnother.attr("disabled", null);
            return;
    
        }
    
        // highlight containing triangle at current level
        var tri = graph.all_triangles[highlight]; 
        var pts = [tri.v1, tri.v2, tri.v3]; 
        pts = _.map(pts, (p) => graph.vertices[p].point); 
        highlightTriangle(pts, "yellow", "yellow"); 
    
        var triangulation = graph.triangulations[len - 1 - step_count];
        drawTriangulation(triangulation, graph); 
    
        // find next highlight 
        if (dag.children(highlight) != undefined) {
            highlight = _.find(dag.children(highlight), function(c) { 
                var t = graph.all_triangles[c]; 
                var pts = [t.v1, t.v2, t.v3]; 
                pts = _.map(pts, (p) => graph.vertices[p].point); 
    
                return util.triangleContainsPoint(query, pts); 
            }); 
        }
    
        if (highlight == undefined) { 
            clear();
    
            d3.select("#console").text("SUCCESS: Point located!");
    
            drawTriangulation(_.first(graph.triangulations), graph);  
            drawPoint(query, "green");
    
            buttons.step.attr("disabled", "disabled"); 
            buttons.locateAnother.attr("disabled", null);
            return;
        }
    
        // re-draw query 
        drawPoint(query, "green");
    
        while (_.contains(graph.triangulations[len - 1 - step_count], highlight)) {
            step_count++; 
        }
    }); 
    
    buttons.locateAnother.on("click", locatePoint); 
    
    buttons.reset.on("click", reset); 
    },{"./point-location":3,"./util":4,"underscore":6}],3:[function(require,module,exports){
    /* 
        Contains code for Planar Graph, triangulation, finding independent sets, 
        and removing vertices from graph (creating DAG structure) 
    */
    
    var _ = require('underscore'); 
    var earcut = require('earcut'); // triangulation library  
    var util = require('./util'); 
    var DAG = require('./dag'); 
    
    var PlanarGraph = function() {
        this.vertices = []; 
        this.adj = []; // adjacency list 
        this.all_triangles = []; // all distinct triangles created 
        this.triangulations = []; // array of lists containing triangulations at each level (triangle ids)
        this.numVertices = 0; 
    }; 
    
    var Point = function(a, b) { 
        this.x = a; 
        this.y = b; 
    };  
    
    var Vertex = function(a, b) {
        this.id = -1;   
        this.point = new Point(a, b);  
        this.triangles = [];
        this.removed = false; 
    }; 
    
    // creates triangle from 3 vertex ids   
    var Triangle = function(a, b, c) { 
        this.v1 = a; 
        this.v2 = b; 
        this.v3 = c; 
    }; 
    
    Vertex.prototype.addTriangle = function(triangle_id) { 
        if (!_.contains(this.triangles, triangle_id)) { 
            this.triangles.push(triangle_id); 
        }
    };
    
    Vertex.prototype.removeTriangle = function(triangle_id) { 
        this.triangles = _.reject(this.triangles, function(t) { return t == triangle_id; }); 
    }; 
    
    PlanarGraph.prototype.addVertex = function(a, b) {
        var v = new Vertex(a, b);
        v.id = this.vertices.length;
    
        this.vertices.push(v);
        this.adj.push([]); 
        this.numVertices++; 
    
        return v.id; 
    };
    
    PlanarGraph.prototype.neighbors = function(v) { 
        return this.adj[v]; 
    }; 
    
    PlanarGraph.prototype.degree = function(v) {
        return this.adj[v].length;
    };
    
    // will only add to adj lists of both if not already present 
    PlanarGraph.prototype.connect = function(v1, v2) {  
        if (!_.contains(this.adj[v1], v2) && !_.contains(this.adj[v2], v1)) {
            this.addDirectedEdge(v1, v2); 
            this.addDirectedEdge(v2, v1); 
        }   
    };
    
    PlanarGraph.prototype.addDirectedEdge = function(v1, v2) {
        this.adj[v1].push(v2); 
    };
    
    PlanarGraph.prototype.removeDirectedEdge = function(v1, v2) { 
        this.adj[v1] = _.reject(this.adj[v1], function(v) { return v == v2; }); 
    };  
    
    // removes the vertex from its connections in the graph
    // returns array of old triangle ids and array of bounding vertex ids (polygon to be re-triangulated)
    PlanarGraph.prototype.removeVertex = function(v) { 
        this.vertices[v].removed = true; 
        this.numVertices--;
    
        var neighbors = this.adj[v]; 
        var self = this; 
    
        // remove edges from v to neighbors 
        _.each(neighbors, function(n) { 
            self.removeDirectedEdge(v, n); 
            self.removeDirectedEdge(n, v); 
        }); 
    
        // copy v's triangles (old triangles)
        var old_triangle_ids = _.map(this.vertices[v].triangles, function(t) { return t; }); 
    
        var polygon = []; 
    
        // array of arrays of vertex ids (without v)
        var triangles = _.map(this.vertices[v].triangles, function(t_id) { 
            var t = self.all_triangles[t_id]; 
            return _.reject(_.values(t), function(v2) { return v2 == v; });          
        }); 
    
        // collect bounding vertices in CW order (polygon to be re-triangulated)
        var next = _.first(triangles);
        polygon.push(_.first(next)); 
        var query = _.last(next); 
        polygon.push(query);  
        triangles = _.rest(triangles, 1); 
        for (var i = 0; i < neighbors.length-2; i++) { 
            // find element with query 
            var next = _.find(triangles, function(t) { return _.contains(t, query); });
            var old_query = query; 
            var query = (_.first(next) == query) ? _.last(next) : _.first(next); 
            polygon.push(query); 
            triangles = _.reject(triangles, function(t) { return _.contains(t, old_query); });  
        }
    
        // go through v's triangles, remove each from all participating vertices 
        _.each(old_triangle_ids, function(t_id) { 
            var t = self.all_triangles[t_id]; 
            self.vertices[t.v1].removeTriangle(t_id); 
            self.vertices[t.v2].removeTriangle(t_id);
            self.vertices[t.v3].removeTriangle(t_id); 
        }); 
    
        return { 
            old_triangles: old_triangle_ids,
            polygon: polygon
        };
    }; 
    
    PlanarGraph.prototype.removeDirectedEdge = function(v1, v2) { 
        this.adj[v1] = _.reject(this.adj[v1], function(v) { return v == v2; }); 
    };  
    
    /* TRIANGULATION FUNCTIONS */ 
    
    // input = graph and array of vertex ids, output = array of arrays of triangles (vertex ids)
    var getTriangulation = function(graph, polygon, hole) { 
        var input = []; 
    
        _.each(polygon, function(v) { 
            input.push(graph.vertices[v].point.x); 
            input.push(graph.vertices[v].point.y); 
        }); 
    
        var triangulations; 
        if (hole != null) { 
            var hole_index = input.length / 2; 
            _.each(hole, function(v) { 
                input.push(graph.vertices[v].point.x); 
                input.push(graph.vertices[v].point.y); 
            }); 
    
            triangulations = earcut(input, [hole_index]); 
        } else { 
            triangulations = earcut(input); 
        }
        
        var output = []; 
        for (var i = 0; i < triangulations.length; i += 3) { 
            var id1 = triangulations[i]; 
            var id2 = triangulations[i+1];
            var id3 = triangulations[i+2];
    
            var p1 = (id1 < polygon.length) ? polygon[id1] : hole[id1 - polygon.length];
            var p2 = (id2 < polygon.length) ? polygon[id2] : hole[id2 - polygon.length];
            var p3 = (id3 < polygon.length) ? polygon[id3] : hole[id3 - polygon.length];
    
            output.push([p1, p2, p3]); 
        }
    
        return output; 
    }; 
    
    // input = graph and array of vertex ids, output = array of new triangle ids s
    var triangulate = function(graph, polygon, hole) {
        var triangles = getTriangulation(graph, polygon, hole); 
        var new_triangle_ids = []; 
    
        _.each(triangles, function(t) { 
            // connect all three vertices in triangle 't' 
            graph.connect(t[0], t[1]);
            graph.connect(t[1], t[2]); 
            graph.connect(t[2], t[0]); 
    
            // create new triangle 
            var tri = new Triangle(t[0], t[1], t[2]);
            var triangle_id = graph.all_triangles.length; 
            new_triangle_ids.push(triangle_id);  
            graph.all_triangles.push(tri); 
    
            // add new triangle to each of the three vertices' lists 
            graph.vertices[t[0]].addTriangle(triangle_id); 
            graph.vertices[t[1]].addTriangle(triangle_id); 
            graph.vertices[t[2]].addTriangle(triangle_id); 
        }); 
    
        return new_triangle_ids; 
    }; 
    
    /* ACTIONS RELATED TO INDEX.JS */ 
    
    var outer_triangle = [{ x: 325, y: 5 }, { x: 650, y: 650 }, { x: 5, y: 650 }];
    var outer_boundary = [{x:5, y: 5},{x:650, y:5},{ x: 650, y: 650 }, { x: 5, y: 650 }];
    console.log("boundary");
    
    // input = array of Points, output = resulting graph (w/ outer triangle) 
    var run = function(pts) { 
        var graph = new PlanarGraph(); 
        var polygon = [];
        console.log("run"); 
    
        _.each(pts, function(p, i) { 
            graph.addVertex(p.x, p.y); 
            if (i != 0) { 
                graph.connect(i, i-1); 
            }
            polygon.push(i); 
        }); 
    
        graph.connect(0, pts.length-1);
    
        var inner_triangles = triangulate(graph, polygon); 
        // add outer triangle 
        graph.addVertex(outer_triangle[0].x, outer_triangle[0].y); 
        graph.addVertex(outer_triangle[1].x, outer_triangle[1].y); 
        graph.addVertex(outer_triangle[2].x, outer_triangle[2].y); 
    
        graph.connect(pts.length, pts.length+1); 
        graph.connect(pts.length+1, pts.length+2); 
        graph.connect(pts.length, pts.length+2); 
    
        var outer = [pts.length, pts.length+1, pts.length+2]; 
        var outer_triangles = triangulate(graph, outer, polygon); 
    
        graph.triangulations.push(_.union(inner_triangles, outer_triangles)); 
    
        // create new DAG to hold triangle hierarchy
        var dag = new DAG(); 
    
        return {
            graph: graph,
            dag: dag
        }; 
    };
    
    // return next independent set in graph 
    var findIndependentSet = function(graph) { 
        // look through all vertices (except last three) 
        var set = []; 
        var forbidden = []; 
        for (var i = 0; i < graph.vertices.length-3; i++) { 
            if (!graph.vertices[i].removed) {
                if (!_.contains(forbidden, i)) {
                    if (graph.degree(i) <= 8) { 
                        set.push(i); 
                        _.each(graph.neighbors(i), function(n) { 
                            forbidden.push(n); 
                        }); 
                    }   
                } 
            }
        }
    
        return set; 
    }; 
    
    // remove verts from graph, re-triangulate holes in graph, add old/new triangle links to DAG 
    var removeVertices = function(graph, verts, dag) { 
        var triangles = _.map(_.last(graph.triangulations), function(t) { return t; }); // last triangulation
        
        _.each(verts, function(v) { 
            var res = graph.removeVertex(v); 
    
            // remove old triangles from previous triangulation
            triangles = _.reject(triangles, function(t) { return _.contains(res.old_triangles, t); }); 
            var new_triangles = triangulate(graph, res.polygon); 
            
            // add new triangles to triangulation 
            _.each(new_triangles, (t) => triangles.push(t)); 
    
            // compare old/new triangles to form links in DAG 
            _.each(res.old_triangles, function(o) { 
                _.each(new_triangles, function(n) { 
                    if (util.trianglesIntersect(o, n, graph)) { 
                        dag.addDirectedEdge(n, o); 
                    }
                }); 
            }); 
        }); 
    
        graph.triangulations.push(triangles); // save as next triangulation
    }; 
    
    module.exports = { 
        run: run,
        findIndependentSet: findIndependentSet,
        removeVertices: removeVertices,
        outer_triangle: outer_triangle,
        outer_boundary: outer_boundary
    }; 
    
    
    
    },{"./dag":1,"./util":4,"earcut":5,"underscore":6}],4:[function(require,module,exports){
    /* 
        Utility functions for testing point containment and side/triangle intersections 
    */ 
    
    var _ = require('underscore'); 
    
    var ccw = function(a, b, c) { 
        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y); 
    };
    
    var triangleContainsPoint = function(p, tri) { 
        var p1 = tri[0]; 
        var p2 = tri[1]; 
        var p3 = tri[2]; 
    
        return ((ccw(p1, p2, p) > 0) && (ccw(p2, p3, p) > 0) && (ccw(p3, p1, p) > 0)); 
    };
    
    var squareContainsPoint = function(p, squ) { 
        var p1 = squ[0]; 
        // var p2 = squ[1]; 
        var p3 = squ[2];
        // var p4 = squ[3]; 
    
        if (p.x < p1.x){
            return false;
        }
        if (p.x < p1.y){
            return false;
        } 
        if (p.x > p3.x){
            return false;
        } 
        if (p.y > p3.y){
            return false;
        }
        return true;
    }; 
    
    var sidesIntersect = function(a, b, c, d) { 
        var int1 = (ccw(a, b, c) > 0) ? (ccw(a, b, d) < 0) : (ccw(a, b, d) > 0);
        var int2 = (ccw(c, d, a) > 0) ? (ccw(c, d, b) < 0) : (ccw(c, d, b) > 0); 
    
        return int1 && int2;  
    }; 
    
    var trianglesIntersect = function(t_id1, t_id2, graph) { 
        var t1 = graph.all_triangles[t_id1]; 
        var t2 = graph.all_triangles[t_id2]; 
    
        var tri1 = [t1.v1, t1.v2, t1.v3]; 
        var tri2 = [t2.v1, t2.v2, t2.v3];
    
        var tri1_pts = _.map(tri1, function(t) { return graph.vertices[t].point; }); 
        var tri2_pts = _.map(tri2, function(t) { return graph.vertices[t].point; }); 
    
        for (var i = 0; i < 3; i++) { 
            for (var j = 0; j < 3; j++) { 
                var a = graph.vertices[tri1[i]].point; 
                var b = graph.vertices[tri1[(i == 2) ? 0 : i+1]].point; 
                var c = graph.vertices[tri2[j]].point; 
                var d = graph.vertices[tri2[(j == 2) ? 0 : j+1]].point; 
    
                if (sidesIntersect(a, b, c, d)) return true; 
    
                if (triangleContainsPoint(tri1_pts[i], tri2_pts, graph) 
                    || triangleContainsPoint(tri2_pts[j], tri1_pts, graph))
                    return true; 
            }
        }
    
        return false; 
    }; 

    var binaryCut = function (points, midList){
        if (points.length <= 3){
            return points;
        }
        var mid = points.length /2;
        mid = parseInt(mid);
        // midList.push((points[mid-1].x + points[mid].x)/2);
        // return {binaryCut(points.slice(0, mid), binaryCut[mid, points.length-1]}; 
        var res = [];
        var left = binaryCut(points.slice(0, mid));
        var right = binaryCut(points.slice(mid, points.length));
        res.push(left);
        res.push(right);
        return res;
    };
    
    module.exports = { 
        ccw: ccw,
        triangleContainsPoint: triangleContainsPoint,
        squareContainsPoint: squareContainsPoint,
        sidesIntersect: sidesIntersect,
        trianglesIntersect: trianglesIntersect,
        binaryCut: binaryCut
    }; 
    },{"underscore":6}],5:[function(require,module,exports){
    'use strict';
    
    module.exports = earcut;
    
    function earcut(data, holeIndices, dim) {
    
        dim = dim || 2;
    
        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];
    
        if (!outerNode) return triangles;
    
        var minX, minY, maxX, maxY, x, y, size;
    
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
    
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
    
            // minX, minY and size are later used to transform coords into integers for z-order calculation
            size = Math.max(maxX - minX, maxY - minY);
        }
    
        earcutLinked(outerNode, triangles, dim, minX, minY, size);
    
        return triangles;
    }
    
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var sum = 0,
            i, j, last;
    
        // calculate original winding order of a polygon ring
        for (i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
    
        // link points into circular doubly-linked list in the specified winding order
        if (clockwise === (sum > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }
    
        return last;
    }
    
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
    
        var p = start,
            again;
        do {
            again = false;
    
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) return null;
                again = true;
    
            } else {
                p = p.next;
            }
        } while (again || p !== end);
    
        return end;
    }
    
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (!ear) return;
    
        // interlink polygon nodes in z-order
        if (!pass && size) indexCurve(ear, minX, minY, size);
    
        var stop = ear,
            prev, next;
    
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
    
            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
    
                removeNode(ear);
    
                // skipping the next vertice leads to less sliver triangles
                ear = next.next;
                stop = next.next;
    
                continue;
            }
    
            ear = next;
    
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
    
                // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
    
                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                }
    
                break;
            }
        }
    }
    
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
    
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }
    
        return true;
    }
    
    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    
        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);
    
        // first look for points inside the triangle in increasing z-order
        var p = ear.nextZ;
    
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.nextZ;
        }
    
        // then look for points in decreasing z-order
        p = ear.prevZ;
    
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }
    
        return true;
    }
    
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;
    
            // a self-intersection where edge (v[i-1],v[i]) intersects (v[i+1],v[i+2])
            if (intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
    
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
    
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
    
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
    
        return p;
    }
    
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);
    
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
    
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;
    
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
    
        queue.sort(compareX);
    
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
    
        return outerNode;
    }
    
    function compareX(a, b) {
        return a.x - b.x;
    }
    
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;
    
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
    
        if (!m) return null;
    
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
    
        var stop = m,
            tanMin = Infinity,
            tan;
    
        p = m.next;
    
        while (p !== stop) {
            if (hx >= p.x && p.x >= m.x &&
                    pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) {
    
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
    
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
    
            p = p.next;
        }
    
        return m;
    }
    
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, size) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
    
        p.prevZ.nextZ = null;
        p.prevZ = null;
    
        sortLinked(p);
    }
    
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;
    
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
    
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
    
                qSize = inSize;
    
                while (pSize > 0 || (qSize > 0 && q)) {
    
                    if (pSize === 0) {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    } else if (qSize === 0 || !q) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else if (p.z <= q.z) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
    
                    if (tail) tail.nextZ = e;
                    else list = e;
    
                    e.prevZ = tail;
                    tail = e;
                }
    
                p = q;
            }
    
            tail.nextZ = null;
            inSize *= 2;
    
        } while (numMerges > 1);
    
        return list;
    }
    
    // z-order of a point given coords and size of the data bounding box
    function zOrder(x, y, minX, minY, size) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
    
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
    
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
    
        return x | (y << 1);
    }
    
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x) leftmost = p;
            p = p.next;
        } while (p !== start);
    
        return leftmost;
    }
    
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
               (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
               (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
               locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    
    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
               area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);
    
        return false;
    }
    
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);
    
        return inside;
    }
    
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;
    
        a.next = b;
        b.prev = a;
    
        a2.next = an;
        an.prev = a2;
    
        b2.next = a2;
        a2.prev = b2;
    
        bp.next = b2;
        b2.prev = bp;
    
        return b2;
    }
    
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
    
        if (!last) {
            p.prev = p;
            p.next = p;
    
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
    
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    
    function Node(i, x, y) {
        // vertice index in coordinates array
        this.i = i;
    
        // vertex coordinates
        this.x = x;
        this.y = y;
    
        // previous and next vertice nodes in a polygon ring
        this.prev = null;
        this.next = null;
    
        // z-order curve value
        this.z = null;
    
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
    
        // indicates whether this is a steiner point
        this.steiner = false;
    }
    
    },{}],6:[function(require,module,exports){
    //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    
    (function() {
    
      // Baseline setup
      // --------------
    
      // Establish the root object, `window` in the browser, or `exports` on the server.
      var root = this;
    
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
    
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    
      // Create quick reference variables for speed access to core prototypes.
      var
        push             = ArrayProto.push,
        slice            = ArrayProto.slice,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;
    
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind,
        nativeCreate       = Object.create;
    
      // Naked function reference for surrogate-prototype-swapping.
      var Ctor = function(){};
    
      // Create a safe reference to the Underscore object for use below.
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
    
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for the old `require()` API. If we're in
      // the browser, add `_` as a global object.
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
    
      // Current version.
      _.VERSION = '1.8.3';
    
      // Internal function that returns an efficient (for current engines) version
      // of the passed-in callback, to be repeatedly applied in other Underscore
      // functions.
      var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1: return function(value) {
            return func.call(context, value);
          };
          case 2: return function(value, other) {
            return func.call(context, value, other);
          };
          case 3: return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
          case 4: return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
        }
        return function() {
          return func.apply(context, arguments);
        };
      };
    
      // A mostly-internal function to generate callbacks that can be applied
      // to each element in a collection, returning the desired result — either
      // identity, an arbitrary callback, a property matcher, or a property accessor.
      var cb = function(value, context, argCount) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
      };
      _.iteratee = function(value, context) {
        return cb(value, context, Infinity);
      };
    
      // An internal function for creating assigner functions.
      var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
          var length = arguments.length;
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      };
    
      // An internal function for creating a new object that inherits from another.
      var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result;
      };
    
      var property = function(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      };
    
      // Helper for collection methods to determine whether a collection
      // should be iterated as an array or as an object
      // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
      // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = property('length');
      var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
      };
    
      // Collection Functions
      // --------------------
    
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles raw objects in addition to array-likes. Treats all
      // sparse array-likes as if they were dense.
      _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
          }
        }
        return obj;
      };
    
      // Return the results of applying the iteratee to each element.
      _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
    
      // Create a reducing function iterating left or right.
      function createReduce(dir) {
        // Optimized iterator function as using arguments.length
        // in the main function will deoptimize the, see #1991.
        function iterator(obj, iteratee, memo, keys, index, length) {
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        }
    
        return function(obj, iteratee, memo, context) {
          iteratee = optimizeCb(iteratee, context, 4);
          var keys = !isArrayLike(obj) && _.keys(obj),
              length = (keys || obj).length,
              index = dir > 0 ? 0 : length - 1;
          // Determine the initial value if none is provided.
          if (arguments.length < 3) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
          }
          return iterator(obj, iteratee, memo, keys, index, length);
        };
      }
    
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`.
      _.reduce = _.foldl = _.inject = createReduce(1);
    
      // The right-associative version of reduce, also known as `foldr`.
      _.reduceRight = _.foldr = createReduce(-1);
    
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function(obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
          key = _.findIndex(obj, predicate, context);
        } else {
          key = _.findKey(obj, predicate, context);
        }
        if (key !== void 0 && key !== -1) return obj[key];
      };
    
      // Return all the elements that pass a truth test.
      // Aliased as `select`.
      _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      };
    
      // Return all the elements for which a truth test fails.
      _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
      };
    
      // Determine whether all of the elements match a truth test.
      // Aliased as `all`.
      _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      };
    
      // Determine if at least one element in the object matches a truth test.
      // Aliased as `any`.
      _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      };
    
      // Determine if the array or object contains a given item (using `===`).
      // Aliased as `includes` and `include`.
      _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
      };
    
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          var func = isFunc ? method : value[method];
          return func == null ? func : func.apply(value, args);
        });
      };
    
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
      };
    
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
      };
    
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
      };
    
      // Return the maximum element (or element-based computation).
      _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value > result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Return the minimum element (or element-based computation).
      _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value < result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Shuffle a collection, using the modern version of the
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
      _.shuffle = function(obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
          rand = _.random(0, index);
          if (rand !== index) shuffled[index] = shuffled[rand];
          shuffled[rand] = set[index];
        }
        return shuffled;
      };
    
      // Sample **n** random values from a collection.
      // If **n** is not specified, returns a single random element.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj)) obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
    
      // Sort the object's values by a criterion produced by an iteratee.
      _.sortBy = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iteratee(value, index, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
    
      // An internal function used for aggregate "group by" operations.
      var group = function(behavior) {
        return function(obj, iteratee, context) {
          var result = {};
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
          });
          return result;
        };
      };
    
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value); else result[key] = [value];
      });
    
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function(result, value, key) {
        result[key] = value;
      });
    
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++; else result[key] = 1;
      });
    
      // Safely create a real, live array from anything iterable.
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
      };
    
      // Return the number of elements in an object.
      _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
      };
    
      // Split a collection into two arrays: one whose elements all satisfy the given
      // predicate, and one whose elements all do not satisfy the predicate.
      _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        _.each(obj, function(value, key, obj) {
          (predicate(value, key, obj) ? pass : fail).push(value);
        });
        return [pass, fail];
      };
    
      // Array Functions
      // ---------------
    
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
      };
    
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N.
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      };
    
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array.
      _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
      };
    
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array.
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
    
      // Trim out all falsy values from an array.
      _.compact = function(array) {
        return _.filter(array, _.identity);
      };
    
      // Internal implementation of a recursive `flatten` function.
      var flatten = function(input, shallow, strict, startIndex) {
        var output = [], idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            //flatten current level of array or arguments object
            if (!shallow) value = flatten(value, shallow, strict);
            var j = 0, len = value.length;
            output.length += len;
            while (j < len) {
              output[idx++] = value[j++];
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      };
    
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
      };
    
      // Return a version of the array that does not contain the specified value(s).
      _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
      };
    
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i],
              computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value);
            }
          } else if (!_.contains(result, value)) {
            result.push(value);
          }
        }
        return result;
      };
    
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = function() {
        return _.uniq(flatten(arguments, true, true));
      };
    
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item)) continue;
          for (var j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item)) break;
          }
          if (j === argsLength) result.push(item);
        }
        return result;
      };
    
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = function(array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function(value){
          return !_.contains(rest, value);
        });
      };
    
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = function() {
        return _.unzip(arguments);
      };
    
      // Complement of _.zip. Unzip accepts an array of arrays and groups
      // each array's elements on shared indices
      _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
    
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index);
        }
        return result;
      };
    
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
    
      // Generator function to create the findIndex and findLastIndex functions
      function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      }
    
      // Returns the first index on an array-like that passes a predicate test
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
    
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
      };
    
      // Generator function to create the indexOf and lastIndexOf functions
      function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == 'number') {
            if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      }
    
      // Return the position of the first occurrence of an item in an array,
      // or -1 if the item is not included in the array.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        step = step || 1;
    
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
    
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start;
        }
    
        return range;
      };
    
      // Function (ahem) Functions
      // ------------------
    
      // Determines whether to execute a function as a constructor
      // or a normal function with the provided arguments
      var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
      };
    
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
        var args = slice.call(arguments, 2);
        var bound = function() {
          return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
      };
    
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context. _ acts
      // as a placeholder, allowing any combination of arguments to be pre-filled.
      _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      };
    
      // Bind a number of an object's methods to that object. Remaining arguments
      // are the method names to be bound. Useful for ensuring that all callbacks
      // defined on an object belong to it.
      _.bindAll = function(obj) {
        var i, length = arguments.length, key;
        if (length <= 1) throw new Error('bindAll must be passed function names');
        for (i = 1; i < length; i++) {
          key = arguments[i];
          obj[key] = _.bind(obj[key], obj);
        }
        return obj;
      };
    
      // Memoize an expensive function by storing its results.
      _.memoize = function(func, hasher) {
        var memoize = function(key) {
          var cache = memoize.cache;
          var address = '' + (hasher ? hasher.apply(this, arguments) : key);
          if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize.cache = {};
        return memoize;
      };
    
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function(){
          return func.apply(null, args);
        }, wait);
      };
    
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = _.partial(_.delay, _, 1);
    
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };
        return function() {
          var now = _.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
    
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
    
        var later = function() {
          var last = _.now() - timestamp;
    
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              if (!timeout) context = args = null;
            }
          }
        };
    
        return function() {
          context = this;
          args = arguments;
          timestamp = _.now();
          var callNow = immediate && !timeout;
          if (!timeout) timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
    
          return result;
        };
      };
    
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
      };
    
      // Returns a negated version of the passed-in predicate.
      _.negate = function(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      };
    
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      };
    
      // Returns a function that will only be executed on and after the Nth call.
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
    
      // Returns a function that will only be executed up to (but not including) the Nth call.
      _.before = function(times, func) {
        var memo;
        return function() {
          if (--times > 0) {
            memo = func.apply(this, arguments);
          }
          if (times <= 1) func = null;
          return memo;
        };
      };
    
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = _.partial(_.before, 2);
    
      // Object Functions
      // ----------------
    
      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
      var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
      var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                          'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    
      function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
    
        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
    
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
          }
        }
      }
    
      // Retrieve the names of an object's own properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`
      _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve all the property names of an object.
      _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve the values of an object's properties.
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
    
      // Returns the results of applying the iteratee to each element of the object
      // In contrast to _.map it returns an object
      _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys =  _.keys(obj),
              length = keys.length,
              results = {},
              currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
      };
    
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
      };
    
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
    
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
    
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = createAssigner(_.allKeys);
    
      // Assigns a given object with all the own properties in the passed-in object(s)
      // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
      _.extendOwn = _.assign = createAssigner(_.keys);
    
      // Returns the first key on an object that passes a predicate test
      _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      };
    
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = function(object, oiteratee, context) {
        var result = {}, obj = object, iteratee, keys;
        if (obj == null) return result;
        if (_.isFunction(oiteratee)) {
          keys = _.allKeys(obj);
          iteratee = optimizeCb(oiteratee, context);
        } else {
          keys = flatten(arguments, false, false, 1);
          iteratee = function(value, key, obj) { return key in obj; };
          obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
      };
    
       // Return a copy of the object without the blacklisted properties.
      _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee);
        } else {
          var keys = _.map(flatten(arguments, false, false, 1), String);
          iteratee = function(value, key) {
            return !_.contains(keys, key);
          };
        }
        return _.pick(obj, iteratee, context);
      };
    
      // Fill in a given object with default properties.
      _.defaults = createAssigner(_.allKeys, true);
    
      // Creates an object that inherits from the given prototype object.
      // If additional properties are provided then they will be added to the
      // created object.
      _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
      };
    
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
    
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
    
      // Returns whether an object has a given set of `key:value` pairs.
      _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
    
    
      // Internal recursive comparison function for `isEqual`.
      var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        }
    
        var areArrays = className === '[object Array]';
        if (!areArrays) {
          if (typeof a != 'object' || typeof b != 'object') return false;
    
          // Objects with different constructors are not equivalent, but `Object`s or `Array`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                   _.isFunction(bCtor) && bCtor instanceof bCtor)
                              && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] === a) return bStack[length] === b;
        }
    
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
    
        // Recursively compare objects and arrays.
        if (areArrays) {
          // Compare array lengths to determine if a deep comparison is necessary.
          length = a.length;
          if (length !== b.length) return false;
          // Deep compare the contents, ignoring non-numeric properties.
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          // Deep compare objects.
          var keys = _.keys(a), key;
          length = keys.length;
          // Ensure that both objects contain the same number of properties before comparing deep equality.
          if (_.keys(b).length !== length) return false;
          while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
      };
    
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function(a, b) {
        return eq(a, b);
      };
    
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
      };
    
      // Is a given value a DOM element?
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
    
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === '[object Array]';
      };
    
      // Is a given variable an object?
      _.isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
      };
    
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
      _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
        _['is' + name] = function(obj) {
          return toString.call(obj) === '[object ' + name + ']';
        };
      });
    
      // Define a fallback version of the method in browsers (ahem, IE < 9), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return _.has(obj, 'callee');
        };
      }
    
      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
      // IE 11 (#1621), and in Safari 8 (#1929).
      if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        _.isFunction = function(obj) {
          return typeof obj == 'function' || false;
        };
      }
    
      // Is a given object a finite number?
      _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
    
      // Is the given value `NaN`? (NaN is the only number which does not equal itself).
      _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
      };
    
      // Is a given value a boolean?
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
      };
    
      // Is a given value equal to null?
      _.isNull = function(obj) {
        return obj === null;
      };
    
      // Is a given variable undefined?
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
    
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
      };
    
      // Utility Functions
      // -----------------
    
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
    
      // Keep the identity function around for default iteratees.
      _.identity = function(value) {
        return value;
      };
    
      // Predicate-generating functions. Often useful outside of Underscore.
      _.constant = function(value) {
        return function() {
          return value;
        };
      };
    
      _.noop = function(){};
    
      _.property = property;
    
      // Generates a function for a given object that returns a given property.
      _.propertyOf = function(obj) {
        return obj == null ? function(){} : function(key) {
          return obj[key];
        };
      };
    
      // Returns a predicate for checking whether an object has a given set of
      // `key:value` pairs.
      _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
          return _.isMatch(obj, attrs);
        };
      };
    
      // Run a function **n** times.
      _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
      };
    
      // Return a random integer between min and max (inclusive).
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
    
      // A (possibly faster) way to get the current timestamp as an integer.
      _.now = Date.now || function() {
        return new Date().getTime();
      };
    
       // List of HTML entities for escaping.
      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      };
      var unescapeMap = _.invert(escapeMap);
    
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      var createEscaper = function(map) {
        var escaper = function(match) {
          return map[match];
        };
        // Regexes for identifying a key that needs to be escaped
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function(string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
    
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function(object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
          value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
      };
    
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
    
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate    : /<%([\s\S]+?)%>/g,
        interpolate : /<%=([\s\S]+?)%>/g,
        escape      : /<%-([\s\S]+?)%>/g
      };
    
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
    
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'":      "'",
        '\\':     '\\',
        '\r':     'r',
        '\n':     'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    
      var escapeChar = function(match) {
        return '\\' + escapes[match];
      };
    
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      // NB: `oldSettings` only exists for backwards compatibility.
      _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
    
        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
    
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, escapeChar);
          index = offset + match.length;
    
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
    
          // Adobe VMs need the match returned to produce the correct offest.
          return match;
        });
        source += "';\n";
    
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    
        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';
    
        try {
          var render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
    
        var template = function(data) {
          return render.call(this, data, _);
        };
    
        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';
    
        return template;
      };
    
      // Add a "chain" function. Start chaining a wrapped Underscore object.
      _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
      };
    
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
    
      // Helper function to continue chaining intermediate results.
      var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
      };
    
      // Add your own custom functions to the Underscore object.
      _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result(this, func.apply(_, args));
          };
        });
      };
    
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
    
      // Add all mutator Array functions to the wrapper.
      _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
          return result(this, obj);
        };
      });
    
      // Add all accessor Array functions to the wrapper.
      _.each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return result(this, method.apply(this._wrapped, arguments));
        };
      });
    
      // Extracts the result from a wrapped and chained object.
      _.prototype.value = function() {
        return this._wrapped;
      };
    
      // Provide unwrapping proxy for some methods used in engine operations
      // such as arithmetic and JSON stringification.
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    
      _.prototype.toString = function() {
        return '' + this._wrapped;
      };
    
      // AMD registration happens at the end for compatibility with AMD loaders
      // that may not enforce next-turn semantics on modules. Even though general
      // practice for AMD registration is to be anonymous, underscore registers
      // as a named module because, like jQuery, it is a base library that is
      // popular enough to be bundled in a third party lib, but not be part of
      // an AMD load request. Those cases could generate an error when an
      // anonymous define() is called outside of a loader request.
      if (typeof define === 'function' && define.amd) {
        define('underscore', [], function() {
          return _;
        });
      }
    }.call(this));
    
    },{}]},{},[2]);
    